/* FONTS:
 2014-06-28 09:43:06.352 RectRotate[2477:60b] Font: Thonburi ...
 2014-06-28 09:43:06.354 RectRotate[2477:60b] Font: Snell Roundhand ...
 2014-06-28 09:43:06.355 RectRotate[2477:60b] Font: Academy Engraved LET ...
 2014-06-28 09:43:06.355 RectRotate[2477:60b] Font: Marker Felt ...
 2014-06-28 09:43:06.355 RectRotate[2477:60b] Font: Avenir ...
 2014-06-28 09:43:06.356 RectRotate[2477:60b] Font: Geeza Pro ...
 2014-06-28 09:43:06.356 RectRotate[2477:60b] Font: Arial Rounded MT Bold ...
 2014-06-28 09:43:06.356 RectRotate[2477:60b] Font: Trebuchet MS ...
 2014-06-28 09:43:06.357 RectRotate[2477:60b] Font: Arial ...
 2014-06-28 09:43:06.357 RectRotate[2477:60b] Font: Marion ...
 2014-06-28 09:43:06.358 RectRotate[2477:60b] Font: Menlo ...
 2014-06-28 09:43:06.358 RectRotate[2477:60b] Font: Malayalam Sangam MN ...
 2014-06-28 09:43:06.358 RectRotate[2477:60b] Font: Kannada Sangam MN ...
 2014-06-28 09:43:06.359 RectRotate[2477:60b] Font: Gurmukhi MN ...
 2014-06-28 09:43:06.359 RectRotate[2477:60b] Font: Bodoni 72 Oldstyle ...
 2014-06-28 09:43:06.359 RectRotate[2477:60b] Font: Bradley Hand ...
 2014-06-28 09:43:06.360 RectRotate[2477:60b] Font: Cochin ...
 2014-06-28 09:43:06.360 RectRotate[2477:60b] Font: Sinhala Sangam MN ...
 2014-06-28 09:43:06.361 RectRotate[2477:60b] Font: Hiragino Kaku Gothic ProN ...
 2014-06-28 09:43:06.362 RectRotate[2477:60b] Font: Iowan Old Style ...
 2014-06-28 09:43:06.362 RectRotate[2477:60b] Font: Damascus ...
 2014-06-28 09:43:06.362 RectRotate[2477:60b] Font: Al Nile ...
 2014-06-28 09:43:06.363 RectRotate[2477:60b] Font: Farah ...
 2014-06-28 09:43:06.363 RectRotate[2477:60b] Font: Papyrus ...
 2014-06-28 09:43:06.363 RectRotate[2477:60b] Font: Verdana ...
 2014-06-28 09:43:06.364 RectRotate[2477:60b] Font: Zapf Dingbats ...
 2014-06-28 09:43:06.364 RectRotate[2477:60b] Font: DIN Condensed ...
 2014-06-28 09:43:06.364 RectRotate[2477:60b] Font: Avenir Next Condensed ...
 2014-06-28 09:43:06.365 RectRotate[2477:60b] Font: Courier ...
 2014-06-28 09:43:06.365 RectRotate[2477:60b] Font: Hoefler Text ...
 2014-06-28 09:43:06.365 RectRotate[2477:60b] Font: Euphemia UCAS ...
 2014-06-28 09:43:06.366 RectRotate[2477:60b] Font: Helvetica ...
 2014-06-28 09:43:06.366 RectRotate[2477:60b] Font: Hiragino Mincho ProN ...
 2014-06-28 09:43:06.366 RectRotate[2477:60b] Font: Bodoni Ornaments ...
 2014-06-28 09:43:06.366 RectRotate[2477:60b] Font: Superclarendon ...
 2014-06-28 09:43:06.367 RectRotate[2477:60b] Font: Mishafi ...
 2014-06-28 09:43:06.367 RectRotate[2477:60b] Font: Optima ...
 2014-06-28 09:43:06.367 RectRotate[2477:60b] Font: Gujarati Sangam MN ...
 2014-06-28 09:43:06.368 RectRotate[2477:60b] Font: Devanagari Sangam MN ...
 2014-06-28 09:43:06.368 RectRotate[2477:60b] Font: Apple Color Emoji ...
 2014-06-28 09:43:06.368 RectRotate[2477:60b] Font: Savoye LET ...
 2014-06-28 09:43:06.369 RectRotate[2477:60b] Font: Kailasa ...
 2014-06-28 09:43:06.369 RectRotate[2477:60b] Font: Times New Roman ...
 2014-06-28 09:43:06.369 RectRotate[2477:60b] Font: Telugu Sangam MN ...
 2014-06-28 09:43:06.369 RectRotate[2477:60b] Font: Heiti SC ...
 2014-06-28 09:43:06.370 RectRotate[2477:60b] Font: Apple SD Gothic Neo ...
 2014-06-28 09:43:06.370 RectRotate[2477:60b] Font: Futura ...
 2014-06-28 09:43:06.370 RectRotate[2477:60b] Font: Bodoni 72 ...
 2014-06-28 09:43:06.371 RectRotate[2477:60b] Font: Baskerville ...
 2014-06-28 09:43:06.371 RectRotate[2477:60b] Font: Symbol ...
 2014-06-28 09:43:06.371 RectRotate[2477:60b] Font: Heiti TC ...
 2014-06-28 09:43:06.371 RectRotate[2477:60b] Font: Copperplate ...
 2014-06-28 09:43:06.372 RectRotate[2477:60b] Font: Party LET ...
 2014-06-28 09:43:06.372 RectRotate[2477:60b] Font: American Typewriter ...
 2014-06-28 09:43:06.372 RectRotate[2477:60b] Font: Chalkboard SE ...
 2014-06-28 09:43:06.373 RectRotate[2477:60b] Font: Avenir Next ...
 2014-06-28 09:43:06.373 RectRotate[2477:60b] Font: Bangla Sangam MN ...
 2014-06-28 09:43:06.373 RectRotate[2477:60b] Font: Noteworthy ...
 2014-06-28 09:43:06.373 RectRotate[2477:60b] Font: Zapfino ...
 2014-06-28 09:43:06.374 RectRotate[2477:60b] Font: Tamil Sangam MN ...
 2014-06-28 09:43:06.374 RectRotate[2477:60b] Font: Chalkduster ...
 2014-06-28 09:43:06.374 RectRotate[2477:60b] Font: Arial Hebrew ...
 2014-06-28 09:43:06.374 RectRotate[2477:60b] Font: Georgia ...
 2014-06-28 09:43:06.375 RectRotate[2477:60b] Font: Helvetica Neue ...
 2014-06-28 09:43:06.375 RectRotate[2477:60b] Font: Gill Sans ...
 2014-06-28 09:43:06.375 RectRotate[2477:60b] Font: Palatino ...
 2014-06-28 09:43:06.376 RectRotate[2477:60b] Font: Courier New ...
 2014-06-28 09:43:06.376 RectRotate[2477:60b] Font: Oriya Sangam MN ...
 2014-06-28 09:43:06.376 RectRotate[2477:60b] Font: Didot ...
 2014-06-28 09:43:06.376 RectRotate[2477:60b] Font: DIN Alternate ...
 2014-06-28 09:43:06.377 RectRotate[2477:60b] Font: Bodoni 72 Smallcaps ...
 */

//
//  ViewController.m
//  RectRotate
//
//  Created by Samuel Noyes on 2/12/14.
//  Copyright (c) 2014 Samuel Noyes. All rights reserved.
//




//   *****************                  ******                ****                       ****
//   *****************                 ***  ***               *** **                   ** ***
//   ***                              ***    ***              ***  ***               ***  ***
//   ***                             ***      ***             ***   ***             ***   ***
//   ***                            ***        ***            ***    ***           ***    ***
//   ***                           ***          ***           ***     ***         ***     ***
//   *****************            *** ********** ***          ***      ***       ***      ***
//   *****************           *** ************ ***         ***       ***     ***       ***
//                 ***          ***                ***        ***        ***   ***        ***
//                 ***         ***                  ***       ***         *** ***         ***
//                 ***        ***                    ***      ***          *****          ***
//                 ***       ***                      ***     ***           ***           ***
//   *****************      ***                        ***    ***                         ***
//   *****************     ***                          ***   ***                         ***
//



/*Taking programmatic screenshot:
 
 if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)])
 UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, [UIScreen mainScreen].scale);
 else
 UIGraphicsBeginImageContext(self.view.bounds.size);
 [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
 UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
 UIGraphicsEndImageContext();
 NSData * data = UIImagePNGRepresentation(image);
 [data writeToFile:@"foo.png" atomically:YES];
 UIImageWriteToSavedPhotosAlbum([UIImage imageWithData:data], nil, nil, nil);*/

#import "ViewController.h"
#import <RevMobAds/RevMobAds.h>
#import "OptionsViewController.h"
#import <AVFoundation/AVFoundation.h>
#import "AudioPlayer.h"
#import "AppDelegate.h"
#import "Appirater.h"
#import <CoreMotion/CoreMotion.h>
#import "Reachability.h"
#import <SystemConfiguration/SystemConfiguration.h>
#import "DoubleTiltedBlock.h"
#import "Passage.h"
#import "Settings.h"
#import "Rectangle.h"
#import "GameOverView.h"

//#ifdef __APPLE__
    //#include "TargetConditionals.h"
//#endif

@interface ViewController ()



@property (strong, nonatomic) AVAudioPlayer *player;
@property (strong, nonatomic) Rectangle *rectView;
@property (strong,nonatomic) NSMutableArray *blocksArray;
@property (nonatomic) int count;
@property (nonatomic) int blockCount;
@property (nonatomic) int score;
@property (nonatomic) int rotatorCount;
@property (nonatomic) double add;
@property (nonatomic) BOOL left;
@property (nonatomic) BOOL adSessionStarted;
@property (nonatomic) BOOL right;
@property (nonatomic) BOOL dead;
@property (nonatomic) BOOL liteVersion;
@property (nonatomic) double msBetweenBlocks;
@property (strong, nonatomic) UILabel *scoreLabel;
@property (strong, nonatomic) UIButton *pauseButton;
@property (nonatomic) BOOL paused;
@property (strong, nonatomic) UIButton *resume;
@property (strong, nonatomic) UIButton *mainMenu;
@property (strong, nonatomic) UIButton *restart;
@property (strong, nonatomic) UIButton *rightButton;
@property (strong, nonatomic) UIButton *leftButton;
@property (nonatomic) int difficulty;
@property (nonatomic) int valueX;
@property (nonatomic) int numOfSpeedUps;
@property (strong, nonatomic) UILabel *loading;
@property (nonatomic) int unfreezesCount;
@property (nonatomic) int dieCount;
@property (nonatomic) int adCount;
@property (nonatomic, strong) GameOverView* gameOverView;
@property (nonatomic, strong) UITextView *lastMessage;
@property (nonatomic, strong) CMMotionManager *motionManager;
@property (nonatomic, readonly, strong) Settings *settings;

@end



@implementation ViewController
#define RECT_WIDTH self.view.frame.size.width/7
#define RECT_HEIGHT self.view.frame.size.height/43
#define BUT_WIDTH self.view.frame.size.width/2
#define BUT_HEIGHT self.view.frame.size.height
#define USER_BUT_HEIGHT self.view.frame.size.height/15
#define USER_BUT_WIDTH self.view.frame.size.width/3
#define HIGHSCORE_KEY @"highscore5"
#define ACCELEROMETER_SPEED .01
#define ROTATOR_SPEED .02
#define SPEED_UP_SPEED 7
#define ADD_STARTING_VAL self.view.frame.size.height/((1/(ROTATOR_SPEED/.01))*640)
#define CONNECTION_TIMEOUT 2
#define AD_COUNT @"advertisementCount"



- (void)viewDidLoad
{
    [super viewDidLoad];
    
    AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];
    if (appDelegate.paused) {
        appDelegate.paused = NO;
    }
    self.adSessionStarted = appDelegate.adSessionStarted;
    
#ifdef LITE
    self.liteVersion = YES;
#endif
    
    self.dieCount = 0;
    self.unfreezesCount = 0;
    
    dispatch_async(dispatch_get_main_queue(), ^(void){
        [self startRevMob];
    });
    
    
    self.numOfSpeedUps=0;//This counts the number of times the game sped up since the last rise in difficulty level (which affects the tilt of the passages)
    self.difficulty = 4;//This is used to make the passages tilt more as the game goes on
    
    self.scoreLabel = [[UILabel alloc] initWithFrame:CGRectMake(self.view.frame.size.width/2-15, 30, 70, 30)];
    [self.scoreLabel setAttributedText:[[NSAttributedString alloc] initWithString:@"0" attributes:@{NSFontAttributeName : [UIFont systemFontOfSize:75]}]];
    [self.scoreLabel setBackgroundColor:[UIColor clearColor]];
    [self.view addSubview:self.scoreLabel];
    self.rotatorCount = 0;//count of repetitions of rotater method; involved in speeding up the movement of the passages.
    self.add = ADD_STARTING_VAL;//self.add is the number of points to add to the y value of each passage each repetition of the rotater method.  It gets larger and larger as the game goes on.
    self.view.autoresizesSubviews = NO;//This just ensures none of the views I positioned get moved automatically
    self.blocksArray = [[NSMutableArray alloc] init];//Array of all passages
    
    self.rectView = [[Rectangle alloc] initWithFrame:CGRectMake(self.view.frame.size.width/2-RECT_WIDTH/2, self.view.frame.size.height-RECT_HEIGHT-self.view.frame.size.height/7, RECT_WIDTH, RECT_HEIGHT)];
    [self.rectView setNeedsDisplay];
    [self.view addSubview:self.rectView];

    [self updateScoreLabel];
    
    _settings = [Settings getSavedSettings];
    
    [self.view setBackgroundColor:self.settings.backgroundColor];
    
    
    //The following adds the two tilt buttons, each of which take up half of the screen
    [self addButtons];
    
    [NSTimer scheduledTimerWithTimeInterval:ROTATOR_SPEED target:self selector:@selector(rotater:) userInfo:nil repeats:YES];//Calls the main game method


    self.motionManager = [[CMMotionManager alloc] init];
    self.motionManager.accelerometerUpdateInterval  = ROTATOR_SPEED; // Update at 10Hz
    if (self.motionManager.accelerometerAvailable) {
        NSOperationQueue *queue = [NSOperationQueue currentQueue];
        [self.motionManager startAccelerometerUpdatesToQueue:queue
                                            withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {
                                                CMAcceleration acceleration = accelerometerData.acceleration;
                                                self.valueX = acceleration.x*(self.view.frame.size.width/((1/(ROTATOR_SPEED/.03))*12));//Scaled movement - faster on an iPad
                                            }];
        
    }
    
    
    //Create Pause Button:
    self.pauseButton = [self createGenericButtonForView:self.view rightAligned:YES leftAligned:NO centered:NO yCoord:20 centeredOnY:NO withText:@"Pause"];
    //Has to be type custom or else it gets screwed up in ios 6
    [self.pauseButton addTarget:self action:@selector(togglePause) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:self.pauseButton];
    //****************
    
    [self sendBlock];//just send one block so the user doesn't have to wait
}


- (void) startRevMob {
    //Reachability *networkReachability = [Reachability reachabilityForInternetConnection];
    //NetworkStatus networkStatus = [networkReachability currentReachabilityStatus];
    if (!self.adSessionStarted) {
        //if (networkStatus == NotReachable) {
        //NSLog(@"There IS NO internet connection");
        //} else {
        //NSLog(@"There IS internet connection");
        [RevMobAds startSessionWithAppID:@"5398cd8a6417062307c101de" andDelegate:self];
        //}
    }
    [RevMobAds session].parallaxMode = RevMobParallaxModeDefault;
    [RevMobAds session].connectionTimeout = CONNECTION_TIMEOUT;
}

- (void) addButtons {
    self.leftButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [self.leftButton setTitle:@"" forState:UIControlStateNormal];
    self.leftButton.frame = CGRectMake(0, 0, BUT_WIDTH, BUT_HEIGHT);
    [self.leftButton addTarget:self action:@selector(rotateLeft:) forControlEvents:UIControlEventTouchDown|UIControlEventTouchDragEnter];
    [self.leftButton addTarget:self action:@selector(stopRotateLeft:) forControlEvents:UIControlEventTouchUpInside|UIControlEventTouchDragExit];
    [self.view addSubview:self.leftButton];
    self.rightButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [self.rightButton setTitle:@"" forState:UIControlStateNormal];
    self.rightButton.frame = CGRectMake(BUT_WIDTH,0, BUT_WIDTH, BUT_HEIGHT);
    [self.rightButton addTarget:self action:@selector(rotateRight:) forControlEvents:UIControlEventTouchDown|UIControlEventTouchDragEnter];
    [self.rightButton addTarget:self action:@selector(stopRotateRight:) forControlEvents:UIControlEventTouchUpInside|UIControlEventTouchDragExit];
    [self.view addSubview:self.rightButton];
}

-(void)revmobSessionIsStarted {
    self.adSessionStarted = YES;
    AppDelegate *delegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];
    delegate.adSessionStarted = YES;
    
}

-(void)revmobSessionNotStartedWithError:(NSError *)error {
    NSLog(@"[RevMob Sample App] Session failed to start: %@", error);
}

- (void) revmobAdDidFailWithError:(NSError *)error {
    
}

+ (NSString *) highscoreKey {
    return HIGHSCORE_KEY;
}

- (void) moveRight {
    self.valueX = 2;
    int newX = (int)(self.rectView.center.x + self.valueX);
    
    if (newX > self.view.frame.size.width-RECT_WIDTH/2)
        newX = self.view.frame.size.width-RECT_WIDTH/2;
    
    if (newX < 0 + RECT_WIDTH/2)
        newX = 0 + RECT_WIDTH/2;
    
    CGPoint newCenter = CGPointMake(newX, self.rectView.center.y);
    if (!self.dead && !self.paused)
        self.rectView.center = newCenter;
}

- (void) stopMoveRight {
    self.valueX = 0;
    int newX = (int)(self.rectView.center.x + self.valueX);
    
    if (newX > self.view.frame.size.width-RECT_WIDTH/2)
        newX = self.view.frame.size.width-RECT_WIDTH/2;
    
    if (newX < 0 + RECT_WIDTH/2)
        newX = 0 + RECT_WIDTH/2;
    
    CGPoint newCenter = CGPointMake(newX, self.rectView.center.y);
    if (!self.dead && !self.paused)
        self.rectView.center = newCenter;
}

- (void) moveLeft {
    self.valueX = -2;
    int newX = (int)(self.rectView.center.x + self.valueX);
    
    if (newX > self.view.frame.size.width-RECT_WIDTH/2)
        newX = self.view.frame.size.width-RECT_WIDTH/2;
    
    if (newX < 0 + RECT_WIDTH/2)
        newX = 0 + RECT_WIDTH/2;
    
    CGPoint newCenter = CGPointMake(newX, self.rectView.center.y);
    if (!self.dead && !self.paused)
        self.rectView.center = newCenter;
}

- (void) stopMoveLeft {
    self.valueX = 0;
    int newX = (int)(self.rectView.center.x + self.valueX);
    
    if (newX > self.view.frame.size.width-RECT_WIDTH/2)
        newX = self.view.frame.size.width-RECT_WIDTH/2;
    
    if (newX < 0 + RECT_WIDTH/2)
        newX = 0 + RECT_WIDTH/2;
    
    CGPoint newCenter = CGPointMake(newX, self.rectView.center.y);
    if (!self.dead && !self.paused)
        self.rectView.center = newCenter;
}

- (void) togglePause {
    self.pauseButton.hidden = !self.pauseButton.hidden;
    self.paused = !self.paused;
    if (self.paused) {
        int lastY = [self showActionButtons];//Since showActionButtons only reveals the main menu and restart buttons, this adds the resume button onto the end.  The return of showActionButtons is the y value of the bottom of the main menu button so that buttons can be added underneath it.
        self.resume = [self createGenericButtonForView:self.view rightAligned:NO leftAligned:NO centered:YES yCoord:lastY+ self.view.frame.size.height/20 centeredOnY:NO withText:@"Resume"];
        [self.resume addTarget:self action:@selector(togglePause) forControlEvents:UIControlEventTouchUpInside];
        [self.view addSubview:self.resume];
    }
    else {
        [self.resume removeFromSuperview];
        [self.mainMenu removeFromSuperview];
        [self.restart removeFromSuperview];
        for (UIView *view in self.view.subviews) {
            view.alpha = 1;
        }
    }
}



- (int) showActionButtons {//reveals the restart and the main menu button
    //Restart:
    self.restart = [self createGenericButtonForView:self.view rightAligned:NO leftAligned:NO centered:YES yCoord:self.view.frame.size.height/2 centeredOnY:YES withText:@"Restart"];
    [self.restart setFrame: CGRectMake(self.restart.frame.origin.x, self.view.frame.size.height/2-(self.restart.frame.size.height/2+self.restart.frame.size.height), self.restart.frame.size.width, self.restart.frame.size.height)];
    [self.restart addTarget:self action:@selector(restartGame) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:self.restart];
    //************************************
    
    //Main Menu:
    self.mainMenu = [self createGenericButtonForView:self.view rightAligned:NO leftAligned:NO centered:YES yCoord:self.restart.frame.origin.y + self.restart.frame.size.height + self.view.frame.size.height/20 centeredOnY:NO withText:@"Main Menu"];
    [self.mainMenu addTarget:self action:@selector(goToMainMenu) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:self.mainMenu];
    
    for (UIView *view in self.blocksArray) {
        view.alpha = 0.3;
    }
    
    self.rectView.alpha = 0.3;
    int rtn = self.mainMenu.frame.origin.y+self.mainMenu.frame.size.height;
    return rtn;//rtn is the bottom y coordinate of the mainmenu button so that buttons can be added under it (such as the resume button)
}

+(int)generateRandomNumberBetweenMin:(int)min Max:(int)max//Just makes things easier
{
    return ( (arc4random() % (max-min+1)) + min );
}

#define TILTED_BLOCK_SUBVIEW_COUNT 20
#define SPACE self.view.frame.size.width/4.75f
#define BLOCK_HEIGHT 40

-(void)sendBlock {//send a passage (formerly known as a "block")
    if (!self.dead && !self.paused) {
        int reversedDifficulty = [self reverseDifficulty: self.difficulty];
        int rand = arc4random()%100;
        int baseProb = 10;
        if (rand<baseProb*reversedDifficulty && !self.liteVersion) {
            [self sendDoubleTiltedBlock];
        }
        else {
            TiltedBlock *block = [[TiltedBlock alloc] initRandomTiltedBlockWithSpace:SPACE andNumOfViews:TILTED_BLOCK_SUBVIEW_COUNT inView:self.view difficulty:self.difficulty rectSize:RECT_WIDTH];//Creates a view with the tilted subviews inside it for simplicity's sake
            [block setFrame:CGRectMake(0, -block.frame.size.height, block.frame.size.width, block.frame.size.height)];
            [self.blocksArray addObject:block];
            [self.view insertSubview:block belowSubview:self.scoreLabel];
        }
    }
}

- (int) reverseDifficulty: (int) difficulty {
    int reversedDifficulty = difficulty;
    reversedDifficulty -= 4;
    reversedDifficulty *= (-1);
    return reversedDifficulty;
}

+ (int) getTiltedBlockNumOfSubviews {
    return TILTED_BLOCK_SUBVIEW_COUNT;
}

- (void) sendDoubleTiltedBlock {
    DoubleTiltedBlock *block = [[DoubleTiltedBlock alloc] initWithOneTiltedBlock:[[TiltedBlock alloc] initRandomTiltedBlockWithSpace:SPACE andNumOfViews:TILTED_BLOCK_SUBVIEW_COUNT inView:self.view difficulty:self.difficulty rectSize:RECT_WIDTH] inView:self.view withDifficulty:self.difficulty];
    [block setFrame:CGRectMake(0, -block.frame.size.height, block.frame.size.width, block.frame.size.height)];
    [self.blocksArray addObject:block];
    [self.view insertSubview:block belowSubview:self.scoreLabel];
}

- (double) msBetweenBlocks {
    double ms;
    if ([self.blocksArray count]>0) {
        if ([[self.blocksArray objectAtIndex:[self.blocksArray count]-1] isKindOfClass:[DoubleTiltedBlock class]]) {
            DoubleTiltedBlock *block = (DoubleTiltedBlock *)[self.blocksArray objectAtIndex:[self.blocksArray count]-1];
            ms=(((self.view.frame.size.height/1.5)+block.frame.size.height)/self.add)*(ROTATOR_SPEED*1000);//This is the number of milliseconds between the release of passages (formerly known as "blocks").  It is set so that it will drop another block when the last block gets two thirds of the way down the screen.
        }
        else if ([[self.blocksArray objectAtIndex:[self.blocksArray count]-1] isKindOfClass:[TiltedBlock class]]) {
            TiltedBlock *block = [self.blocksArray objectAtIndex:[self.blocksArray count]-1];
            ms=(((self.view.frame.size.height/2)+block.frame.size.height)/self.add)*(ROTATOR_SPEED*1000);
        }
        else {
            ms=((self.view.frame.size.height/3)/self.add)*(ROTATOR_SPEED*1000);
        }
    }
    else {
        ms=((self.view.frame.size.height/3)/self.add)*(ROTATOR_SPEED*1000);
    }
    return ms;
}

-(void)rotater:(id)sender {
    AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];
    if (appDelegate.paused && !self.paused && !self.dead) {
        [self togglePause];
        appDelegate.paused = NO;
    }
    else if (appDelegate.paused && self.paused && !self.dead) {
        appDelegate.paused = NO;
    }
    if (!self.paused) {
        self.rotatorCount++;//counts repetitions of the rotator methods and speeds up passages every so often
        if (self.rotatorCount>=SPEED_UP_SPEED/ROTATOR_SPEED) {
            [self speedUp];
            self.rotatorCount = 0;
        }
        [self updatePosition];
        if (self.left) {
            self.rectView.transform = CGAffineTransformRotate(self.rectView.transform, -(((ROTATOR_SPEED/.01))*.07));
        }
        if (self.right) {
            self.rectView.transform = CGAffineTransformRotate(self.rectView.transform, (((ROTATOR_SPEED/.01))*.07));
        }
        
        for (int i =0; i<[self.blocksArray count]; i++) {//Goes through the array of passages and checks each one to see if it has passed the rectangle.  If so, it grays them out.
            
            TiltedBlock *view = self.blocksArray[i];
            if (view.frame.origin.y>self.rectView.frame.origin.y+self.rectView.frame.size.height && ![view isBeaten]) {
                if ([self.blocksArray[i] isKindOfClass:[DoubleTiltedBlock class]]) {
                    self.score +=2;
                }
                else if ([self.blocksArray[i] isKindOfClass:[TiltedBlock class]]) {
                    self.score++;
                }
                [view becomeBeaten];
                [self updateScoreLabel];
                view.alpha = .5;
                for (int j = 0; j<TILTED_BLOCK_SUBVIEW_COUNT*2; j++) {
                    @try {
                        UIView *view2 = self.blocksArray[i-j];
                        view2.alpha = .5;
                    }
                    @catch (NSException *exception) {
                        
                    }
                }
                break;
            }
        }
        for (int i =0; i<[self.blocksArray count]; i++) {//move each passage and check for collisions with the rectangle
            Passage *view = self.blocksArray[i];
                view.frame = CGRectOffset(view.frame, 0, self.add); // offset by an amount
            self.blocksArray[i] = view;
            if (view.frame.origin.y>self.view.frame.size.height) {
                [self.blocksArray removeObject:view];
                [view removeFromSuperview];
                view = nil;
            }
            else {
                for (UIView *v in view.subviewArray) {
                    CGRect frame = [v convertRect:v.bounds toView:self.view];
                    UIView *subview = [[UIView alloc] initWithFrame:frame];
                    if ((subview.frame.origin.y+subview.frame.size.height)>=self.rectView.frame.origin.y) {
                        if (CGRectIntersectsRect(self.rectView.frame, subview.frame)) {//Not accurate, but has to return true in order for next part to be true: just economizes
                            if([self checkIntersection:self.rectView andView:subview] && self.dieCount == 0) {//Accurate intersection checker
                                [self die:sender];//You're dead!
                                self.dieCount++;
                                
                                if (self.liteVersion) {
                                        [self freeze];
                                        NSDate *date = [NSDate date];
                                    
                                        NSLog(@"%@",date);
                                        RevMobFullscreen *ad = [[RevMobAds session] fullscreen];
                                        [RevMobAds session].connectionTimeout = CONNECTION_TIMEOUT;
                                        [ad loadWithSuccessHandler:^(RevMobFullscreen *fs) {
                                        [fs showAd];
                                        NSLog(@"Ad loaded");
                                        self.adCount = (int)[[NSUserDefaults standardUserDefaults] integerForKey:AD_COUNT];
                                        self.adCount++;
                                        [[NSUserDefaults standardUserDefaults] setInteger:self.adCount forKey:AD_COUNT];
                                        [[NSUserDefaults standardUserDefaults] synchronize];
                                    } andLoadFailHandler:^(RevMobFullscreen *fs, NSError *error) {
                                        NSLog(@"Ad error: %@",error);
                                        double seconds = [date timeIntervalSinceNow];
                                        seconds*=-1;
                                        NSLog(@"Failed after %f seconds",seconds);
                                        seconds = CONNECTION_TIMEOUT-seconds;
                                        
                                        if (seconds<=0) {
                                            [self showFailedAlert];
                                        }
                                        else {
                                            NSLog(@"Starting timer for %f seconds", seconds);
                                            [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(showFailedAlert) userInfo:nil repeats:NO];
                                        }
                                    } onClickHandler:^{
                                        NSLog(@"Ad clicked");
                                        [self unfreeze];
                                    } onCloseHandler:^{
                                        NSLog(@"Ad closed");
                                        [self unfreeze];
                                        if (self.adCount>7 && self.liteVersion) {
                                            [self askToUpgrade];
                                            self.adCount = 0;
                                            
                                            [[NSUserDefaults standardUserDefaults] setInteger:self.adCount forKey:AD_COUNT];
                                            [[NSUserDefaults standardUserDefaults] synchronize];
                                        }
                                    }];
                                }
//                                else if (self.liteVersion &&!self.adSessionStarted) {
//                                    [self freeze];
//                                    [NSTimer scheduledTimerWithTimeInterval:CONNECTION_TIMEOUT target:self selector:@selector(showFailedAlert) userInfo:nil repeats:NO];
//                                    
//                                }
                                
                            }
                        }
                    }
                }
            }
        }
        
        self.blockCount++;//counts the number of repititions of the rotater method and creates a new block at the correct time
        if (self.blockCount >= self.msBetweenBlocks/(ROTATOR_SPEED*1000)) {
            dispatch_async(dispatch_get_main_queue(), ^(void){
                [self sendBlock];
            });
            self.blockCount = 0;
        }
        
    }
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
    if ([alertView.title isEqualToString:@"Annoyed by the Ads?  Finding the game too easy?"]) {
        if (buttonIndex == 1) {
            [self loadFullVersion];
        }
    }
    else if ([alertView.title isEqualToString:@"Ad Failed"]) {
        self.adCount = (int)[[NSUserDefaults standardUserDefaults] integerForKey:AD_COUNT];
        self.adCount++;
        [[NSUserDefaults standardUserDefaults] setInteger:self.adCount forKey:AD_COUNT];
        [[NSUserDefaults standardUserDefaults] synchronize];
    }
}

- (void) showFailedAlert {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ad Failed" message:@"The Ad failed to load." delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil];
    [alert show];
    [self unfreeze];
}

- (void) askToUpgrade {
    if (self.liteVersion) {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Annoyed by the Ads?  Finding the game too easy?" message:@"If you upgrade to the full version, you'll get: \n-No ads\n-ALL NEW Neon Mode\n-Exciting and Challenging Double Passageways\n\nWould you like to upgrade?" delegate:self cancelButtonTitle:@"No thanks" otherButtonTitles:@"Heck Yeah!", nil];
        
        [alert show];
    }
}

#define APP_STORE_URL @"itms://itunes.apple.com/app/id835923333"

- (void) loadFullVersion {
    NSURL* redirectToURL = [NSURL URLWithString:APP_STORE_URL];
    [[UIApplication sharedApplication] openURL:redirectToURL];
}

- (void) unfreeze {
    if (self.unfreezesCount == 0 && self.rectView.alpha !=1 ) {
        for (UIView *view in self.view.subviews) {
            view.alpha *= 4;
            view.userInteractionEnabled = YES;
        }
        [self.loading removeFromSuperview];
        self.unfreezesCount++;
    }
}

- (void) freeze {
    for (UIView *view in self.view.subviews) {
        view.alpha *= .25;
        view.userInteractionEnabled = NO;
    }
    int labelWidth = self.view.frame.size.width/2;
    int labelHeight = self.view.frame.size.height/20;
    self.loading = [[UILabel alloc] initWithFrame:CGRectMake(self.view.frame.size.width/2-labelWidth/2, self.view.frame.size.height/2-labelHeight/2, labelWidth, labelHeight)];
    self.loading.text = @"Loading...";
    self.loading.font = [UIFont systemFontOfSize:self.view.frame.size.width/5];
    self.loading.textColor = [Settings getSavedSettings].labelColor;
    CGSize stringSize;
    if (floor(NSFoundationVersionNumber) > NSFoundationVersionNumber_iOS_6_1) {
        // here you go with iOS 7
        stringSize = [self.loading.text sizeWithAttributes:@{NSFontAttributeName:self.loading.font}];
    }
    else {
        stringSize = [self.loading.text sizeWithFont:self.loading.font];
    }
    CGFloat width = stringSize.width;
    CGFloat height = stringSize.height;
    [self.loading setFrame:CGRectMake(self.view.frame.size.width/2-width/2, self.view.frame.size.height/2-height/2, width, height)];
    [self.loading setBackgroundColor:[UIColor clearColor]];
    [self.view addSubview:self.loading];
}

#define MS_BETWEEN_BLOCKS_MIN 900

-(void) speedUp {
    double topDifficulty = self.view.frame.size.width/106.66;//fastest the game will go (more accurately this is not the top difficulty but the maximum value of the add variable)
    if (self.add<topDifficulty) {//unless add is at its maximum, speed up
        self.numOfSpeedUps++;
        self.add += .1;
    }
    else {
        self.difficulty = 0;//0 is the hardest difficulty
    }
    if (self.numOfSpeedUps>((topDifficulty-ADD_STARTING_VAL)/.1)/4) {//4 increments of difficulty - slowly makes tilt more and more (difficulty only affects tilt)
        self.numOfSpeedUps = 0;
        self.difficulty--;
    }
}


-(BOOL) checkIntersection:(UIView *) rotatedView andView:(UIView *) nonRotatedView {
    CGAffineTransform t=rotatedView.transform;
    
    CGPoint p=CGPointMake(rotatedView.bounds.size.width/2, rotatedView.bounds.size.height/2);
    
    p.x = -p.x;p.y=-p.y;
    CGPoint tL =CGPointApplyAffineTransform(p, t);
    tL.x +=rotatedView.center.x;
    tL.y +=rotatedView.center.y;
    
    p.x = -p.x;
    CGPoint tR =CGPointApplyAffineTransform(p, t);
    tR.x +=rotatedView.center.x;
    tR.y +=rotatedView.center.y;
    
    p.y=-p.y;
    CGPoint bR =CGPointApplyAffineTransform(p, t);
    bR.x +=rotatedView.center.x;
    bR.y +=rotatedView.center.y;
    
    p.x = -p.x;
    CGPoint bL =CGPointApplyAffineTransform(p, t);
    bL.x +=rotatedView.center.x;
    bL.y +=rotatedView.center.y;
    
    
    //check for edges of nonRotated Rect's edges
    BOOL contains=YES;
    CGFloat value=nonRotatedView.frame.origin.x;
    if(tL.x<value && tR.x<value && bR.x<value && bL.x<value)
        contains=NO;
    value=nonRotatedView.frame.origin.y;
    if(tL.y<value && tR.y<value && bR.y<value && bL.y<value)
        contains=NO;
    value=nonRotatedView.frame.origin.x+nonRotatedView.frame.size.width;
    if(tL.x>value && tR.x>value && bR.x>value && bL.x>value)
        contains=NO;
    value=nonRotatedView.frame.origin.y+nonRotatedView.frame.size.height;
    if(tL.y>value && tR.y>value && bR.y>value && bL.y>value)
        contains=NO;
    
    if(contains==NO){
        return NO;
    }
    //check for roatedView's edges
    CGPoint rotatedVertexArray[]={tL,tR,bR,bL,tL,tR};
    
    CGPoint nonRotatedVertexArray[4];
    nonRotatedVertexArray[0]=CGPointMake(nonRotatedView.frame.origin.x,nonRotatedView.frame.origin.y);
    nonRotatedVertexArray[1]=CGPointMake(nonRotatedView.frame.origin.x+nonRotatedView.frame.size.width,nonRotatedView.frame.origin.y);
    nonRotatedVertexArray[2]=CGPointMake(nonRotatedView.frame.origin.x+nonRotatedView.frame.size.width,nonRotatedView.frame.origin.y+nonRotatedView.frame.size.height);
    nonRotatedVertexArray[3]=CGPointMake(nonRotatedView.frame.origin.x,nonRotatedView.frame.origin.y+nonRotatedView.frame.size.height);
    
    NSInteger i,j;
    for (i=0; i<4; i++) {
        CGPoint first=rotatedVertexArray[i];
        CGPoint second=rotatedVertexArray[i+1];
        CGPoint third=rotatedVertexArray[i+2];
        CGPoint mainVector =CGPointMake(second.x-first.x, second.y-first.y);
        CGPoint selfVector =CGPointMake(third.x-first.x, third.y-first.y);
        BOOL sign;
        sign=[self crossProductOf:mainVector withPoint:selfVector];
        for (j=0; j<4; j++) {
            CGPoint otherPoint=nonRotatedVertexArray[j];
            CGPoint otherVector = CGPointMake(otherPoint.x-first.x, otherPoint.y-first.y);
            BOOL checkSign=[self crossProductOf:mainVector withPoint:otherVector];
            if(checkSign==sign)
                break;
            else if (j==3)
                contains=NO;
        }
        if(contains==NO){
            return NO;
        }
    }
    return YES;
}

-(BOOL)crossProductOf:(CGPoint)point1 withPoint:(CGPoint)point2{
    if((point1.x*point2.y-point1.y*point2.x)>=0)
        return YES;
    else
        return NO;
}

-(void) die:(NSTimer *) timer {
    [Appirater appLaunched:YES];
    [timer invalidate];
    timer = nil;
    self.dead = YES;
    self.pauseButton.hidden = YES;
    self.restart.hidden = YES;
    self.mainMenu.hidden = YES;
    self.resume.hidden = YES;
    [self showGameOverButtons];
    long highscore = [[NSUserDefaults standardUserDefaults] integerForKey:HIGHSCORE_KEY];//retrieve highscore from user defaults (is saved there) and chack to see if the current score is higher.  If so, replace the old highscore
    if (self.score > highscore) {
        [[NSUserDefaults standardUserDefaults] setInteger:self.score forKey:HIGHSCORE_KEY];
        [Appirater userDidSignificantEvent:YES];
        if (self.score-highscore>1) {
            self.lastMessage.text = [NSString stringWithFormat: @"You beat the\nhighscore by\n%ld points. Bravo.", self.score-highscore];
        }
        else {
            self.lastMessage.text = [NSString stringWithFormat: @"You beat the\nhighscore by\n%ld point. Bravo.", self.score-highscore];
        }
        [self.lastMessage setFrame:CGRectMake(self.lastMessage.frame.origin.x, self.lastMessage.frame.origin.y, self.gameOverView.frame.size.width - self.view.frame.size.width/20, 100)];
        [self.lastMessage sizeToFit];
        [self.lastMessage layoutIfNeeded];
        [self updateGameOverView];
    }
}

- (void) updateGameOverView {
    CGFloat componentBuffer = self.view.frame.size.height/25;
    CGFloat sideBuffer = self.view.frame.size.height/17;
    float newHeight = self.lastMessage.frame.size.height + self.restart.frame.size.height + self.mainMenu.frame.size.height + 2*componentBuffer + 2*sideBuffer;
    [self.gameOverView setFrame:CGRectMake(self.gameOverView.frame.origin.x, self.view.frame.size.height/2-newHeight/2, self.gameOverView.frame.size.width, newHeight)];
    [self.lastMessage setFrame:CGRectMake(self.gameOverView.frame.size.width/2-self.lastMessage.frame.size.width/2, sideBuffer, self.lastMessage.frame.size.width, self.lastMessage.frame.size.height)];
    [self.mainMenu setFrame:CGRectMake(self.gameOverView.frame.size.width/2-self.mainMenu.frame.size.width/2, componentBuffer+self.lastMessage.frame.size.height + sideBuffer, self.mainMenu.frame.size.width, self.mainMenu.frame.size.height)];
    [self.restart setFrame:CGRectMake(self.gameOverView.frame.size.width/2-self.restart.frame.size.width/2, sideBuffer+self.lastMessage.frame.size.height + componentBuffer + self.mainMenu.frame.size.height + componentBuffer, self.restart.frame.size.width, self.restart.frame.size.height)];
}

- (void) showGameOverButtons {
    int width = self.view.frame.size.width/1.5;
    int height = self.view.frame.size.height/2;
    self.gameOverView = [[GameOverView alloc] initWithFrame:CGRectMake(-width, self.view.frame.size.height/2-height/2, width, height)];
    
    self.lastMessage = [[UITextView alloc] initWithFrame:CGRectMake(0, 0, 10000, 5000)];
    self.lastMessage.userInteractionEnabled = NO;
    NSArray *gameOverMessages = @[@"You have\nshamed the\nfamily.", @"Tisk Tisk", @"Oh come on.", @"Was that\nreally the\nbest you\ncould do?", @"Pathetic.", @"Let's see\na little\nmore effort.", @"BOOOO!"];
    [self.lastMessage setText:[gameOverMessages objectAtIndex:arc4random()%[gameOverMessages count]]];
    [self.lastMessage setFont:[UIFont fontWithName:@"OCRAStd" size:self.view.frame.size.width/15]];
    [self.lastMessage sizeToFit];
    [self.lastMessage setFrame:CGRectMake(self.gameOverView.frame.size.width/2-self.lastMessage.frame.size.width/2, self.gameOverView.frame.size.height/4-self.lastMessage.frame.size.height/2, self.lastMessage.frame.size.width, self.lastMessage.frame.size.height)];
    [self.lastMessage setBackgroundColor:[UIColor clearColor]];
    self.lastMessage.textAlignment = NSTextAlignmentCenter;
    [self.gameOverView addSubview:self.lastMessage];
    
    self.mainMenu = [self createGenericButtonForView:self.gameOverView rightAligned:NO leftAligned:NO centered:YES yCoord:self.gameOverView.frame.size.height/2 centeredOnY:YES withText:@"Main Menu"];
    [self.mainMenu addTarget:self action:@selector(exitGameOver:) forControlEvents:UIControlEventTouchUpInside];
    [self.gameOverView addSubview:self.mainMenu];
    
    self.restart = [self createGenericButtonForView:self.gameOverView rightAligned:NO leftAligned:NO centered:YES yCoord:(self.gameOverView.frame.size.height/4)*3 centeredOnY:YES withText:@"Restart"];
    [self.restart addTarget:self action:@selector(exitGameOver:) forControlEvents:UIControlEventTouchUpInside];
    [self.gameOverView addSubview:self.restart];
    
    [self.view addSubview:self.gameOverView];
    
    [self updateGameOverView];
    
    [UIView beginAnimations:nil context:nil];
    [UIView setAnimationDuration:0.5];
    [UIView setAnimationDelay:0];
    [UIView setAnimationCurve:UIViewAnimationCurveEaseIn];
    
    CGRect gameOverViewRect = self.gameOverView.frame;
    gameOverViewRect.origin.y = self.view.frame.size.height/2-gameOverViewRect.size.height/2;
    gameOverViewRect.origin.x = self.view.frame.size.width/2 - gameOverViewRect.size.width/2;
    self.gameOverView.frame = gameOverViewRect;
    self.gameOverView.frame = gameOverViewRect;
    
    [UIView commitAnimations];
}

- (void) updateScoreLabel {//Self-explanatory
    [self.scoreLabel setAttributedText:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"%d", self.score] attributes:@{NSFontAttributeName : [UIFont systemFontOfSize:self.view.frame.size.width/5], NSForegroundColorAttributeName : [Settings getSavedSettings].labelColor}]];
    [self.scoreLabel sizeToFit];
    [self.scoreLabel setFrame:CGRectMake(self.view.frame.size.width/2-self.scoreLabel.frame.size.width/2, self.scoreLabel.frame.origin.y, self.scoreLabel.frame.size.width, self.scoreLabel.frame.size.height)];
}

-(IBAction)rotateLeft:(id)sender {
    self.left = YES;
}
-(IBAction)stopRotateLeft:(id)sender {
    self.left = NO;
}
-(IBAction)rotateRight:(id)sender {
    self.right = YES;
}
-(IBAction)stopRotateRight:(id)sender {
    self.right = NO;
}

- (void) exitGameOver: (UIButton *) sender {
    CGRect gameOverViewRect = self.gameOverView.frame;
    gameOverViewRect.origin.y = self.view.frame.size.height/2 - gameOverViewRect.size.height/2;
    gameOverViewRect.origin.x = self.view.frame.size.width;
    
    [UIView beginAnimations:nil context:nil];
    [UIView setAnimationDuration:0.5];
    [UIView setAnimationDelay:0];
    [UIView setAnimationCurve:UIViewAnimationCurveEaseOut];
    
    self.gameOverView.frame = gameOverViewRect;
    self.gameOverView.frame = gameOverViewRect;
    
    [UIView commitAnimations];
    if ([sender.titleLabel.text isEqualToString:@"Main Menu"]) {
        [NSTimer scheduledTimerWithTimeInterval:.5 target:self selector:@selector(goToMainMenu) userInfo:nil repeats:NO];
    }
    else if ([sender.titleLabel.text isEqualToString:@"Restart"]) {
        [NSTimer scheduledTimerWithTimeInterval:.5 target:self selector:@selector(restartGame) userInfo:nil repeats:NO];
    }
}

- (void) restartGame {
    UIViewController* vc =
    [self.storyboard instantiateViewControllerWithIdentifier:@"game"];
    
    [self presentViewController:vc animated:YES completion:nil];
}

- (void) goToMainMenu {
    UIViewController* vc =
    [self.storyboard instantiateViewControllerWithIdentifier:@"main"];
    [self presentViewController:vc animated:YES completion:nil];
}

-(void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration {
    self.valueX = acceleration.x*(self.view.frame.size.width/((1/(ROTATOR_SPEED/.03))*12));//Scaled movement - faster on an iPad
}

-(void) updatePosition {//update rectView according to data from accelerometer
    int newX = (int)(self.rectView.center.x + self.valueX);
    
    if (newX > self.view.frame.size.width-RECT_WIDTH/2)
        newX = self.view.frame.size.width-RECT_WIDTH/2;
    
    if (newX < 0 + RECT_WIDTH/2)
        newX = 0 + RECT_WIDTH/2;
    
    CGPoint newCenter = CGPointMake(newX, self.rectView.center.y);
    if (!self.dead && !self.paused)
        self.rectView.center = newCenter;
}



@end
